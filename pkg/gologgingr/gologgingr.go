// Package gologgingr implements github.com/go-logr/logr.Logger in terms of
// github.com/op/go-logging.
package gologgingr

import (
	"bytes"
	"encoding/json"
	"fmt"
	"sort"

	"github.com/go-logr/logr"
)

// The global verbosity level.  See SetVerbosity().
var globalVerbosity int = 0

// SetVerbosity sets the global level against which all info logs will be
// compared.  If this is greater than or equal to the "V" of the logger, the
// message will be logged.  A higher value here means more logs will be written.
// The previous verbosity value is returned.  This is not concurrent-safe -
// callers must be sure to call it from only one goroutine.
func SetVerbosity(v int) int {
	old := globalVerbosity
	globalVerbosity = v
	return old
}

// New returns a logr.Logger which is implemented by Go's standard
// log package, or something like it.  See New for details.
func New(opts ...Option) logr.Logger {
	options := newOptions(opts...)

	l := logger{
		llog:   options.Logger,
		level:  0,
		prefix: "",
		values: nil,
	}

	return l
}

// LeveledLogger is the subset of the Go stdlib log.Logger API that is needed for
// this adapter.
type LeveledLogger interface {
	Fatal(args ...interface{})
	Error(args ...interface{})
	Warning(args ...interface{})
	Notice(args ...interface{})
	Info(args ...interface{})
	Debug(args ...interface{})
}

type logger struct {
	llog   LeveledLogger
	level  int
	prefix string
	values []interface{}
	depth  int
}

func (l logger) clone() logger {
	out := l
	l.values = copySlice(l.values)
	return out
}

func copySlice(in []interface{}) []interface{} {
	out := make([]interface{}, len(in))
	copy(out, in)
	return out
}

// Magic string for intermediate frames that we should ignore.
const autogeneratedFrameName = "<autogenerated>"

type kvPair struct {
	key string
	val interface{}
}

func flatten(kvList ...interface{}) string {
	keys := make([]string, 0, len(kvList))
	vals := make(map[string]interface{}, len(kvList))
	for i := 0; i < len(kvList); i += 2 {
		k, ok := kvList[i].(string)
		if !ok {
			panic(fmt.Sprintf("key is not a string: %s", pretty(kvList[i])))
		}
		var v interface{}
		if i+1 < len(kvList) {
			v = kvList[i+1]
		}
		keys = append(keys, k)
		vals[k] = v
	}
	sort.Strings(keys)
	buf := bytes.Buffer{}
	for i, k := range keys {
		v := vals[k]
		if i > 0 {
			buf.WriteRune(' ')
		}
		buf.WriteString(pretty(k))
		buf.WriteString("=")
		buf.WriteString(pretty(v))
	}
	return buf.String()
}

func pretty(value interface{}) string {
	jb, _ := json.Marshal(value)
	return string(jb)
}

func (l logger) Info(msg string, kvList ...interface{}) {
	if l.Enabled() {
		lvlStr := flatten("level", l.level)
		msgStr := flatten("msg", msg)
		fixedStr := flatten(l.values...)
		userStr := flatten(kvList...)
		l.output(fmt.Sprintln(l.prefix, lvlStr, msgStr, fixedStr, userStr))
	}
}

func (l logger) Enabled() bool {
	return globalVerbosity >= l.level
}

func (l logger) Error(err error, msg string, kvList ...interface{}) {
	msgStr := flatten("msg", msg)
	var loggableErr interface{}
	if err != nil {
		loggableErr = err.Error()
	}
	errStr := flatten("error", loggableErr)
	fixedStr := flatten(l.values...)
	userStr := flatten(kvList...)
	l.output(fmt.Sprintln(l.prefix, errStr, msgStr, fixedStr, userStr))
}

func (l logger) output(s string) {
	switch l.level {
	case 0:
		l.llog.Error(s)
	case 1:
		l.llog.Error(s)
	case 2:
		l.llog.Warning(s)
	case 3:
		l.llog.Notice(s)
	case 4:
		l.llog.Info(s)
	case 5:
		l.llog.Info(s)
	default:
		l.llog.Debug(s)
	}
}

func (l logger) V(level int) logr.InfoLogger {
	new := l.clone()
	new.level = level
	return new
}

// WithName returns a new logr.Logger with the specified name appended.  stdr
// uses '/' characters to separate name elements.  Callers should not pass '/'
// in the provided name string, but this library does not actually enforce that.
func (l logger) WithName(name string) logr.Logger {
	new := l.clone()
	if len(l.prefix) > 0 {
		new.prefix = l.prefix + "/"
	}
	new.prefix += name
	return new
}

func (l logger) WithValues(kvList ...interface{}) logr.Logger {
	new := l.clone()
	new.values = append(new.values, kvList...)
	return new
}

var _ logr.Logger = logger{}
var _ logr.InfoLogger = logger{}
